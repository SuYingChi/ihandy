package com.ihs.booster.common.asynctask;import android.os.AsyncTask.Status;import android.os.Handler;import android.os.Looper;import android.os.Message;import com.ihs.booster.utils.L;import java.util.ArrayDeque;import java.util.concurrent.BlockingQueue;import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.Executor;import java.util.concurrent.FutureTask;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;import java.util.concurrent.atomic.AtomicBoolean;import java.util.concurrent.atomic.AtomicInteger;/** * Created by sharp on 15/8/10. */public abstract class BoostAsyncTask<Params, Progress, Result> {    private static final int CORE_POOL_SIZE = 0;    private static final int KEEP_ALIVE = 500;    private static final int MESSAGE_POST_RESULT = 0x1;// 消息类型：发送结果    private static final int MESSAGE_POST_PROGRESS = 0x2;// 消息类型：更新进度    private static final int MESSAGE_POST_FINISH = 0x3;// 消息类型：异步执行完成    private static final InternalHandler mHandler = new InternalHandler();    private static final BlockingQueue<Runnable> mPoolWorkQueue = new LinkedBlockingQueue<>(512);    private static final ThreadFactory mThreadFactory = new ThreadFactory() {        private final AtomicInteger mCount = new AtomicInteger(1);        @Override        public Thread newThread(Runnable r) {            int count = mCount.getAndIncrement();            return new Thread(r, "New Thread #" + count);        }    };    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2;    private static OnFinishedListener finishedListener;    // 3种 executor:mThreadPoolExecutor mSmartSerialExecutor mSerialExecutor    public final ThreadPoolExecutor mThreadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,            MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.MILLISECONDS, mPoolWorkQueue, mThreadFactory);    public final Executor mSmartSerialExecutor = new SmartSerialExecutor();    public final Executor mSerialExecutor = new SerialExecutor();    private final WorkerRunnable<Params, Result> mWorker;    private final FutureTask<Result> mFuture;    private final AtomicBoolean mCancelled = new AtomicBoolean();    private final AtomicBoolean mTaskInvoked = new AtomicBoolean();    private volatile Status mStatus = Status.PENDING;    private volatile Executor mDefaultExecutor = mThreadPoolExecutor;    public BoostAsyncTask() {        mWorker = new WorkerRunnable<Params, Result>() {            @Override            public Result call() throws Exception {                mTaskInvoked.set(true);                android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_DISPLAY);                return postResult(doInBackground(mParams));            }        };        mFuture = new FutureTask<Result>(mWorker) {            @Override            protected void done() {                try {                    if (!mTaskInvoked.get()) {                        postResult(get());                    }                } catch (InterruptedException e) {                    L.l("FutureTask InterruptedException:" + getClass().getName() + " msg:" + e.getMessage());                } catch (ExecutionException e) {                    L.l("FutureTask ExecutionException:" + getClass().getName() + " msg:" + e.getMessage());                } catch (CancellationException e) {                    if (!mTaskInvoked.get()) {                        postResult(null);                    }                }            }        };    }    private Result postResult(Result result) {        Message message = mHandler.obtainMessage(MESSAGE_POST_RESULT, new BoostTaskResult<Result>(this, result));        message.sendToTarget();        return result;    }    protected abstract Result doInBackground(Params... params);    public static void setOnFinishedListener(OnFinishedListener finishedListener) {        BoostAsyncTask.finishedListener = finishedListener;    }    public void setDefaultExecutor(Executor exec) {        mDefaultExecutor = exec;    }    public OnFinishedListener getFinishedListener() {        return finishedListener;    }    public final Status getStatus() {        return mStatus;    }    public final boolean cancel(boolean mayInterruptIfRunning) {        mCancelled.set(true);        return mFuture.cancel(mayInterruptIfRunning);    }    public final Result get() throws InterruptedException, ExecutionException {        return mFuture.get();    }    public final Result get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {        return mFuture.get(timeout, unit);    }    protected final void publishProgress(Progress... values) {        if (!isCancelled()) {            mHandler.obtainMessage(MESSAGE_POST_PROGRESS, new BoostTaskResult<Progress>(this, values)).sendToTarget();        }    }    public final boolean isCancelled() {        return mCancelled.get();    }    protected void onProgressUpdate(Progress... values) {    }    private void finish(Result result) {        if (isCancelled()) {            onCancelled(result);            if (finishedListener != null) {                finishedListener.onCancelled();            }        } else {            onPostExecute(result);            if (finishedListener != null) {                finishedListener.onPostExecute();            }        }        mStatus = Status.FINISHED;    }    protected void onCancelled(Result result) {    }    protected void onPostExecute(Result result) {    }    public final BoostAsyncTask<Params, Progress, Result> execute(Params... params) {        return executeOnExecutor(mDefaultExecutor, params);    }    public final BoostAsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {        if (mStatus != Status.PENDING) {            switch (mStatus) {                case RUNNING:                    throw new IllegalStateException("Cannot execute task:" + " the task is already running.");                case FINISHED:                    throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)");                default:                    break;            }        }        mStatus = Status.RUNNING;        onPreExecute();        mWorker.mParams = params;        exec.execute(mFuture);        return this;    }    protected void onPreExecute() {    }    public void execute(Runnable runnable) {        mDefaultExecutor.execute(runnable);    }    enum ScheduleStrategy {        LIFO,        FIFO;    }    private static class InternalHandler extends Handler {        public InternalHandler(Looper looper) {            super(looper);        }        public InternalHandler() {            super(Looper.getMainLooper());        }        @Override        public void handleMessage(Message msg) {            BoostTaskResult result = (BoostTaskResult) msg.obj;            switch (msg.what) {                case MESSAGE_POST_RESULT:                    result.mTask.finish(result.mData[0]);                    break;                case MESSAGE_POST_PROGRESS:                    result.mTask.onProgressUpdate(result.mData);                    break;                case MESSAGE_POST_FINISH:                    if (finishedListener != null) {                        finishedListener.onPostExecute();                    }                    break;            }        }    }    private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {        Params[] mParams;    }    private static class BoostTaskResult<Data> {        final Data[] mData;        final BoostAsyncTask<?, ?, ?> mTask;        BoostTaskResult(BoostAsyncTask<?, ?, ?> task, Data... data) {            mTask = task;            mData = data;        }    }    public static abstract class OnFinishedListener {        public void onCancelled() {        }        public void onPostExecute() {        }    }    private class SerialExecutor implements Executor {        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();        Runnable mActive = null;        @Override        public synchronized void execute(final Runnable runnable) {            mTasks.offer(new Runnable() {                @Override                public void run() {                    try {                        runnable.run();                    } finally {                        scheduleNext();                    }                }            });            if (mActive == null) {                scheduleNext();            }        }        protected synchronized void scheduleNext() {            if ((mActive = mTasks.poll()) != null) {                mThreadPoolExecutor.execute(mActive);            }        }    }    private class SmartSerialExecutor implements Executor {        private final ScheduleStrategy mStrategy = ScheduleStrategy.FIFO;        /**         * 并发最大数量，当投入的任务过多大于此值时，根据Lru规则，将最老的任务移除（将得不到执行） <br>         * cpu count : 1 2 3 4 8 16 32 <br>         * base(cpu+3) : 4 5 6 7 11 19 35 <br>         * max(base*16): 64 80 96 112 176 304 560 <br>         */        private int serialMaxCount = (CPU_COUNT + 3) * 16;        private final ArrayDeque<Runnable> mQueue = new ArrayDeque<Runnable>(serialMaxCount);        /**         * 一次同时并发的数量，根据处理器数量调节 <br>         * 一个时间段内最多并发线程个数： 双核手机：2 四核手机：4 ... 计算公式如下： cpu count : 1 2 3 4 8 16 32 <br>         * once(base*2): 1 2 3 4 8 16 32 <br>         */        private int serialOneTime;        public SmartSerialExecutor() {            reSettings(CPU_COUNT);        }        private void reSettings(int cpuCount) {            serialOneTime = cpuCount;            serialMaxCount = (cpuCount + 3) * 16;        }        @Override        public synchronized void execute(final Runnable command) {            Runnable r = new Runnable() {                @Override                public void run() {                    command.run();                    next();                    mHandler.sendEmptyMessage(MESSAGE_POST_FINISH);                }            };            if ((mThreadPoolExecutor).getActiveCount() < serialOneTime) {                mThreadPoolExecutor.execute(r);            } else {                if (mQueue.size() >= serialMaxCount) {                    mQueue.pollFirst();                }                mQueue.offerLast(r);            }        }        public synchronized void next() {            Runnable mActive;            switch (mStrategy) {                case LIFO:                    mActive = mQueue.pollLast();                    break;                case FIFO:                    mActive = mQueue.pollFirst();                    break;                default:                    mActive = mQueue.pollLast();                    break;            }            if (mActive != null) {                mThreadPoolExecutor.execute(mActive);            }        }    }}